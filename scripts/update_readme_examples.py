#!/usr/bin/env python3
"""
Update the Examples section in README.md by executing real commands and
replacing the content between the markers:

<!-- BEGIN_EXAMPLES -->
... auto-generated content ...
<!-- END_EXAMPLES -->

Run from repo root:
  python scripts/update_readme_examples.py
"""

import sys
import subprocess
from pathlib import Path
from typing import List, Dict

BEGIN_MARKER = "<!-- BEGIN_EXAMPLES -->"
END_MARKER = "<!-- END_EXAMPLES -->"

ROOT = Path(__file__).resolve().parents[1]
README_PATH = ROOT / "README.md"
SCRIPT_REL = "wordagen.py"  # relative to ROOT

PY_DISPLAY = "python"  # what we show in README
PY_EXEC = sys.executable  # what we actually use to run


def run_command(args: List[str]) -> str:
    """Run a command and return stdout. Raise on non-zero exit."""
    proc = subprocess.run(
        [PY_EXEC, SCRIPT_REL, *args],
        cwd=ROOT,
        capture_output=True,
        text=True,
        check=False,
    )
    if proc.returncode != 0:
        msg = f"Command failed ({proc.returncode}): {PY_DISPLAY} {SCRIPT_REL} {' '.join(args)}\nSTDOUT:\n{proc.stdout}\nSTDERR:\n{proc.stderr}"
        raise RuntimeError(msg)
    return proc.stdout.rstrip("\n")


def build_block_line(title: str, args: List[str]) -> str:
    """Build a single example block: title comment, command, output."""
    displayed_cmd = f"{PY_DISPLAY} {SCRIPT_REL} {' '.join(args)}"
    output = run_command(args)
    return "\n".join([
        f"# {title}",
        displayed_cmd,
        output,
        "",  # blank line separator
    ])


def generate_examples_text() -> str:
    """Generate the full code-fenced examples text."""
    examples: List[Dict[str, List[str]]] = [
        {
            "title": "Batch of unique names generated by Markov chains trained on US name lists",
            "args": ["--name", "--order=4", "--count=10"],
        },
        {
            "title": "Spanish nonsense words (Hunspell dictionary with morphological expansion)",
            "args": ["--words=es", "--order=4", "--count=20"],
        },
        {
            "title": "Names starting with a prefix (--prefix automatically enables Markov mode)",
            "args": ["--words=names", "--prefix=joe", "--order=2", "--count=10", "--length=5-20"],
        },
        {
            "title": "Words ending with common suffixes (--suffix automatically enables Markov mode)",
            "args": ["--suffix=ing", "--count=10"],
        },
        {
            "title": "Words with both prefix and suffix",
            "args": ["--prefix=pre", "--suffix=ing", "--count=5", "--order=4", "--length=8-15"],
        },
        {
            "title": "Syllable-based simple algorithm (default)",
            "args": ["--single"],
        },
        {
            "title": "Latin tokens word-word-word (--order automatically enables Markov mode)",
            "args": ["--token", "--order=2", "--words=la"],
        },
    ]

    lines: List[str] = ["```bash"]
    for ex in examples:
        lines.append(build_block_line(ex["title"], ex["args"]))
    lines.append("```")
    return "\n".join(lines).rstrip() + "\n"


def replace_examples_in_readme() -> None:
    """Replace content between markers in README.md."""
    text = README_PATH.read_text(encoding="utf-8")

    if BEGIN_MARKER not in text or END_MARKER not in text:
        raise RuntimeError(
            f"Markers not found in README.md. Please ensure both '{BEGIN_MARKER}' and '{END_MARKER}' exist."
        )

    start = text.index(BEGIN_MARKER) + len(BEGIN_MARKER)
    end = text.index(END_MARKER)
    before = text[:start]
    after = text[end:]

    # Keep a newline after BEGIN_MARKER if not present
    if not before.endswith("\n"):
        before += "\n"

    new_examples = generate_examples_text()

    new_text = before + new_examples + after
    README_PATH.write_text(new_text, encoding="utf-8")


def main():
    try:
        replace_examples_in_readme()
    except Exception as e:
        print(str(e), file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
